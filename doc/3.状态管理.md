#  3.State Management 状态管理

## 3.1 State Backend 
Flink 内置了以下这些开箱即用的 state backends ：

* MemoryStateBackend

* FsStateBackend

* RocksDBStateBackend

如果不设置，默认使用 MemoryStateBackend。

### 3.1.1 MemoryStateBackend
在 MemoryStateBackend 内部，数据以 Java 对象的形式存储在堆中。 Key/value 形式的状态和窗口算子持有存储着状态值、触发器的 hash table。

在 CheckPoint 时，State Backend 对状态进行快照，并将快照信息作为 CheckPoint 应答消息的一部分发送给 JobManager(master)，同时 JobManager 也将快照信息存储在堆内存中。

MemoryStateBackend 能配置异步快照。强烈建议使用异步快照来防止数据流阻塞，注意，异步快照默认是开启的。 用户可以在实例化 MemoryStateBackend 的时候，将相应布尔类型的构造参数设置为 false 来关闭异步快照（仅在 debug 的时候使用），例如：

```java
new MemoryStateBackend(MAX_MEM_STATE_SIZE, false);
```
MemoryStateBackend 的限制：

* 默认情况下，每个独立的状态大小限制是 5 MB。在 MemoryStateBackend 的构造器中可以增加其大小。
* 无论配置的最大状态内存大小（MAX_MEM_STATE_SIZE）有多大，都不能大于 akka frame 大小（看配置参数）。
* 聚合后的状态必须能够放进 JobManager 的内存中。

MemoryStateBackend 适用场景：
* 本地开发和调试。
* 状态很小的 Job，例如：由每次只处理一条记录的函数（Map、FlatMap、Filter 等）构成的 Job。Kafka Consumer 仅仅需要非常小的状态。

建议同时将 managed memory 设为0，以保证将最大限度的内存分配给 JVM 上的用户代码。
### 3.1.2 FsStateBackend
FsStateBackend 需要配置一个文件系统的 URL（类型、地址、路径），例如：”hdfs://namenode:40010/flink/checkpoints” 或 “file:///data/flink/checkpoints”。

FsStateBackend 将正在运行中的状态数据保存在 TaskManager 的内存中。CheckPoint 时，将状态快照写入到配置的文件系统目录中。 少量的元数据信息存储到 JobManager 的内存中（高可用模式下，将其写入到 CheckPoint 的元数据文件中）。

FsStateBackend 默认使用异步快照来防止 CheckPoint 写状态时对数据处理造成阻塞。 用户可以在实例化 FsStateBackend 的时候，将相应布尔类型的构造参数设置为 false 来关闭异步快照，例如：

```java
new FsStateBackend(path, false);
```
FsStateBackend 适用场景:
* 状态比较大、窗口比较长、key/value 状态比较大的 Job。
* 所有高可用的场景。

建议同时将 managed memory 设为0，以保证将最大限度的内存分配给 JVM 上的用户代码。
### 3.1.3 RocksDBStateBacked

*RocksDBStateBackend* 需要配置一个文件系统的 URL （类型、地址、路径），例如：”hdfs://namenode:40010/flink/checkpoints” 或 “file:///data/flink/checkpoints”。

RocksDBStateBackend 将正在运行中的状态数据保存在 [RocksDB](http://rocksdb.org/) 数据库中，RocksDB 数据库默认将数据存储在 TaskManager 的数据目录。 CheckPoint 时，整个 RocksDB 数据库被 checkpoint 到配置的文件系统目录中。 少量的元数据信息存储到 JobManager 的内存中（高可用模式下，将其存储到 CheckPoint 的元数据文件中）。

RocksDBStateBackend 只支持异步快照。

RocksDBStateBackend 的限制：

- 由于 RocksDB 的 JNI API 构建在 byte[] 数据结构之上, 所以每个 key 和 value 最大支持 2^31 字节。 **重要信息**: RocksDB 合并操作的状态（例如：ListState）累积数据量大小可以超过 2^31 字节，但是会在下一次获取数据时失败。这是当前 RocksDB JNI 的限制。

RocksDBStateBackend 的适用场景：

- 状态非常大、窗口非常长、key/value 状态非常大的 Job。
- 所有高可用的场景。

注意，你可以保留的状态大小仅受磁盘空间的限制。与状态存储在内存中的 FsStateBackend 相比，RocksDBStateBackend 允许存储非常大的状态。 然而，这也意味着使用 RocksDBStateBackend 将会使应用程序的最大吞吐量降低。 所有的读写都必须序列化、反序列化操作，这个比基于堆内存的 state backend 的效率要低很多。

请同时参考 [Task Executor 内存配置](https://ci.apache.org/projects/flink/flink-docs-release-1.10/zh/ops/memory/mem_tuning.html#rocksdb-state-backend) 中关于 RocksDBStateBackend 的建议。

RocksDBStateBackend 是目前唯一支持增量 CheckPoint 的 State Backend (见 [这里](https://ci.apache.org/projects/flink/flink-docs-release-1.10/zh/ops/state/large_state_tuning.html))。

可以使用一些 RocksDB 的本地指标(metrics)，但默认是关闭的。你能在 [这里](https://ci.apache.org/projects/flink/flink-docs-release-1.10/zh/ops/config.html#rocksdb-native-metrics) 找到关于 RocksDB 本地指标的文档。

The total memory amount of RocksDB instance(s) per slot can also be bounded, please refer to documentation [here](https://ci.apache.org/projects/flink/flink-docs-release-1.10/zh/ops/state/large_state_tuning.html#bounding-rocksdb-memory-usage) for details.

## 3.2 Kinds of state in Flink 
Flink 中有两种基本的状态：Keyed State 和 Operator State。

Keyed State
Keyed State 通常和 key 相关，仅可使用在 KeyedStream 的方法和算子中。

你可以把 Keyed State 看作分区或者共享的 Operator State, 而且每个 key 仅出现在一个分区内。 逻辑上每个 keyed-state 和唯一元组 <算子并发实例, key> 绑定，由于每个 key 仅”属于” 算子的一个并发，因此简化为 <算子, key>。

Keyed State 会按照 Key Group 进行管理。Key Group 是 Flink 分发 Keyed State 的最小单元； Key Group 的数目等于作业的最大并发数。在执行过程中，每个 keyed operator 会对应到一个或多个 Key Group

Operator State
对于 Operator State (或者 non-keyed state) 来说，每个 operator state 和一个并发实例进行绑定。 Kafka Connector 是 Flink 中使用 operator state 的一个很好的示例。 每个 Kafka 消费者的并发在 Operator State 中维护一个 topic partition 到 offset 的映射关系。

Operator State 在 Flink 作业的并发改变后，会重新分发状态，分发的策略和 Keyed State 不一样。

  * Operator State 
    * List state 
    * Union List state 
    * Broadcast state 
  * Keyed State 
    * Value state 
    * List state 
    * Map state 
## 3.3 Fault Tolerance 容错
  * Checkpointing
    * Barriers
    * Exactly Once & At Least Once 
    * Asynchronous State Snapshots
    * Checkpointing Algorithm(Chandy-Lamport)
    * Incremental Checkpointing
  * Savepoints
## 3.4 State Rescalable 
## 3.5 Queryable Statue 
## 3.6 State Schema Evolution 
## 3.7 State Processor API （read ,write ,and modify savepoints and chekpoints using Flink's batch DataSet API）

## 3.8 参考资料

* [State Backends](https://ci.apache.org/projects/flink/flink-docs-release-1.10/zh/ops/state/state_backends.html)
* [State Backends](https://ci.apache.org/projects/flink/flink-docs-release-1.9/ops/state/state_backends.html)
* [Working with State](https://ci.apache.org/projects/flink/flink-docs-release-1.10/zh/dev/stream/state/state.html)
* [Working with State](https://ci.apache.org/projects/flink/flink-docs-release-1.9/zh/dev/stream/state/state.html)







